01 IO模型
    1.1 IO模型
        IO模型是在长期的工作实践中组织起来的通用IO操作模型，常用IO模型有：
            阻塞IO
            非阻塞IO
            IO多路利用
            信号驱动IO
            异步IO
    1.2 阻塞IO
        1.2.1 定义
            在执行IO操作时如果执行条件不满足则阻塞，阻塞IO是IO的默认形态
        1.2.2 效率：
            阻塞IO是效率很低的一种IO，但是由于逻辑简单所以是默认IO行为
        1.2.3 阻塞情况
            1 因为某种执行条件没有满足造成的函数阻塞
            2 处理IO的时间较长产生的阻塞状态
            3. 网络传输，大文件读写
    1.3 非阻塞IO
        1.3.1 定义
            通过修改IO属性行为，使原本阻塞的IO变为非阻塞的状态，非阻塞IO可防止进程阻塞在I/O操作上，但是
            需要轮询耗费资源较多
        1.3.2 设置套接字为非阻塞IO：
            1.3.2.1 设置函数为非阻塞IO
                sockfd.setblocking(bool)
                功能：设置套接字为非阻塞IO
                参数：默认为True，表示套接字IO阻塞；设置为False则套接字IO变为非阻塞
            1.3.2.2 超时检测
                为了使python的socket具有超时检测功能，需要调用socket的settimeout()函数
                向传递给他的函数表明，经过多少称算是超时。
                稍后访问一个socket，如果经过了参数设定的时间的后，什么都没发生，则就会产生一个
                socket.timeout异常。

                套接字设置超时检测方法：
                s.settimeout(sec)
                功能：设置套接字超时时间
                参数：设置的时间

02 select方法
    2.1 IO多路复用原理
        2.1.1 定义
            I/O多路复用是通过一种机制，可以监视多个描述符，旦某个描述符就绪(一向是读就绪或者写就绪),能
            够通知程序进行的读写操作。
        2.1.2 IO多路复用优点
            IO多路复用本质是一个单线程程序，多线程/多进程处理IO并发方式，一个连接过来开一个进程/线程处理
            这样消耗的内存和进程切换页会耗掉更多的系统资源，所以常常结合IO多路复用和多进程/线程来高性能并发
            ，IO复用负责提高接受socket的通知效率，收到请求后，交给进程/线程来处理逻辑。
    2.2 多路复用提供的方法
        2.2.1 select方法
            2.2.1.1 select特点
                1. select的可移植性好，支持平台多
                2. select对超时值提供了很好的精度，精确到微称，而poll式毫秒
            2.2.1.2 缺点
                1. 单个进程可以监视的fd数量被限制，默认是1024
                2. 需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制
                开销大
                3. 对fd进行扫描时是线性扫描，fd剧增后，IO效率降低，每次调用都对fd进行线性扫描遍历，随着fd
                的增加会造成遍历速度慢的问题。

        2.2.2 select函数
            rs,ws,xs = select(rlist,wlist,xlist[,timeout])
            功能：监控IO事件，阻塞等待IO事件的发生
            参数：
                rlist   列表  存放我们监控等待处理的IO事件
                wlist   列表  存放我们要主动处理的IO事件
                xlist   列表  存放如果发生异常需要我们处理的
                timeout     数字      超时时间
    2.3 基于select实例
        2.3.1 select服务端程序
            < 将关注的IO放入对应的监控类别列表
            < 通过select函数进行监控
            < 遍历select返回值列表，确定就绪IO事件
            < 处理发生的IO事件
        2.3.2 实例
            24003实例

03 poll方法
    3.1 位运算
        定义：将整数转换为二进制，按二进制位进行运算
        运算符号:
            & : 按位与
            | : 按位或
            ^ : 按位异或
            << : 左移
            >> : 右移
    3.2 poll特点
        3.2.1 优点：
            应付大数量的文件描述符时比select要快
            没有最大连接数的限制是基于链表存储的
        3.2.2 缺点：
            大量的fd数组被整体复制于内核态和用户态之间，而不管这样的复制是不是有意义
            同select相同的是调用结束后需要轮询来获取就绪描述符
    3.3 poll函数
        poll实现服务器比select要复杂一些，需要用到register()和unregister()方法，作用是加入和移除对象，poll()的返回
        值包括了文件描述符和事件，polling的事件常量有POLLIN,POLLPRI,POLLPOUT,POLLERR,POLLHUP,POLLVAL,分别表示
        读取数据，读取紧急数据，文件描述符已经准备好，文件描述符出错，连接丢失无效请求。

        3.3.1 创建poll对象
            p = select.poll()

        3.3.2 添加关注对象或取消关注
            p.register(s,POLLIN | POLLERR)
            p.unregister(s)

        3.3.3 进行监控
            events = p.poll()
            功能： 阻塞等待register的事件发生
            返回值：events是一列表，列表中每个元素表示准备就绪需要处理的IO,每个元组第一项描述符第二项表示具体什么就绪，
            格式：[(fileno,event),(),()]
            因此需要通过设置描述符地图来查找具体IO对象，描述符地图：{s.fileno():s}
        3.3.4 处理IO事件
            通过for循环遍历发生的IO调用响应方法执行对应事件

        注意：
            poll实例只能在linux平台进行使用，windows平台无法使用。
04 epoll方法
    4.1 使用方法：代码基本与poll相同
        4.1 将生成对象的poll()函数变为epoll()
        4.2 将register注册IO事件时，关注的事件类别必为epoll类别


    4.2 epoll特点
        epoll效率比select poll要高
        epoll监控IO数量比select要多
        epoll的触发方式比poll要多（EPOLLET边缘触发）

    4.3 多路复用方法对比：
        select : 跨平台性好，执行效率一般，支持同时监控IO数量少。
        poll : 跨平台性一般，执行效率一般，支持同时监控IO数量大
        epoll : 跨平台性差，执行效率高，支持同时监牢IO数量大。


05 HTTPServer实例

    5.1 功能
        1. 接收客户端的HTTP请求
        2. 对请求有一定的解析
        3. 根据请求内容组织响应
        4. 将响应内容返回给客户端

    5.2 特点
        1. 使用多路复用完成并发接收
        2. 使用类进行封装
        3. 能够根据具体请求返回指定的网页