01 自定义线程类和线程效率
    1.1 自定义线程类
        自定义线程类的方法与自定义进程类相似
        步骤如下:
            1. 继承Thread类
            2. 运行Tread类中__init__方法以获取父类属性
            3. 重写父类中run方法

        1.1.1 自定义线程类实例
                """
                    自定义线程类
                """

                from threading import Thread
                from time import sleep, ctime


                class MyThread(Thread):
                    # 定义线程类,并指定属性
                    # 由于target指定线程函数player
                    def __init__(self, target=None, args=(), kwargs={}):
                        super().__init__()
                        self.target = target
                        self.args = args
                        self.kwargs = kwargs

                    # 重写run方法
                    # 如果不重写run方法,自定义线程对象就会调用线程类原来的run方法
                    # 而run方法怎么的指定的player线程函数事件
                    # 由于在自定义线程类中定义的target属性,所以target就是指定的player
                    def run(self):
                        # 如果target代表的是player,而参数由于不确认性,所以需要指定*args **kwargs来指定
                        self.target(*self.args, **self.kwargs)


                def player(song, sec):
                    for i in range(3):
                        sleep(sec)
                        print("Player %s : %s " % (song, ctime()))


                t = MyThread(target=player, args=("葫芦娃", 2))

                t.start()
                t.join()

    1.2 GIL问题
        1.2.1 什么是线程GIL
            GIL称为全局解释器锁,为了利用多核,Python开始支持多线程,而解决多线程之间数据完整性和状态同步的最
            简单方法自然就是加锁,于是有GIL这把超级大锁

            GIL是给解释器进行加锁处理,让解释器同一时刻只能解释一个线程,而当越来越多的代码库开发者接受了这种
            设定后,他们开始大量依赖这种特性,慢慢的这种实现方式被发现是低效的,但当大家试图去拆分和去除GIL的时
            候,发现大量库代码开发者已经重度依赖GIL而非常难以去除了.

        1.2.2 GIL影响
            导致后果:
                因为遇到阻塞时线程主动让出解释器,去解释其他线程,所以Python多线程在执行多阻塞高延迟IO时
                可以提升程序效率,其他情况并不能对效率有所提升.
        1.2.3 关于GIL的建议
            1. 用multiprocess替代Threading
                用multiprocess库的出现很大程序上显了弥补thread库因为GIL而低效的缺陷,它完整的复制了一套
                thread所提供的接口方便迁移,唯一的不同就是它使用了多进程而不多线程.

            2. 用其他解析器
                之前也提到了既然GIL只是CPython的产物,像JPython和IronPython这样解析器由于实现语言特性,
                他们不需要GIL帮助,然后由于用了JAVA/C#用于解析器实现,他们也失去了利用社区众多C语言模块有用
                特性的机会.
    1.3 进程线程的区别和联系
        进程和线程的区别和联系:
        1. 两者都是多任务编程的方式,都能够使用计算机多核心资源
        2. 进程创建和删除要比线程消耗更多计算机资源
        3. 进程空间独立数据安全性好,有专门的通信方法
        4. 线程使用全局变量通信,更加简单,但是往往需要同步互斥操作
        5. 一个进程可以包含多个线程,线程共享进程资源
        6. 进程线程都有自己的特有属性资源,如命令,ID等.


02 多进程多线程并发
    2.1 服务器概述
        硬件服务器:CPU MEM   STORAGE  NETWORK RAID
    2.2 多进程多线程并发
        多进程/多线程并发模型:
            每当一个客户端连接服务器,就创建一个新的进程/线程为该客户端服务,客户端退出时再销毁进程/线程
        优点:能同时满足多个客户端长期占有服务需求,可以处理各种请求
        缺点: 资源消耗大
        适用情况:客户端同时连接量较少,需要处理行为较复杂情况

    2.3 fork多进程并发
        2.3.1 实例步骤
            1. 创建套接字对象
            2. 绑定本机IP
            3. 设置为监听套接字
            4. 等待接受客户端请求 accept
            5. 当有客户端连接服务器,则创建子进程
            6. 子进程处理客户端请求,父进程继续等待其他客户端连接
            7. 客户端退出则子进程退出

    2.4 多线程并发
        每有一个客户端就创建一个新的线程处理客户端请求比多进程.
        优点:资源消耗少
        缺点: 需要处理共享资源,注意GIL问题
        2.4.1 实现步骤
            1. 创建套接字,绑定,监听
            2. 接收客户端请求,创建新的线程
            3. 主线程继续等待其他客户端连接,分支线程执行客户端请求
            4. 处理客户端请求后,分支线程退出,关闭客户端套接字.


03 FTP文件服务器编码综合案例
    具体代码实例：23008FTP_Server.py 23009FTP_Client.py
    3.1 代码功能
        1. 分为服务端和客户端,要求可以有多个客户端同时操作
        2. 客户端可以查看服务器文件库中有什么文件
        3. 客户端可以从文件库中下载文件到本地
        4. 客户端可以上传一个本地文件到文件库
        5. 使用print在客户端打印命令输入提示,引导操作

    3.2 思路分析
        1. 需求分析
        2.

    3.3 技术点
        并发: 多线程并发
        网络: TCP网络
        结构设计: 文件处理功能使用封装
        功能模块:
                网络并发模型搭建
                查看文件库文件
                上传
                下载

        通信协议: 客户端发起请求  服务端处理请求,使用不同字母来代表不同功能
                L : 查看列表
                P : 上传
                G : 下载
                Q : 退出

        功能分析:
            主要是基于各个功能模块进行服务端与客户端各处理什么功能进行分析

            网络并发模型搭建
                服务端:
                客户端:
            查看文件库文件
                服务端:
                客户端:
            上传
                服务端:
                客户端:
            下载
                服务端:
                客户端:





