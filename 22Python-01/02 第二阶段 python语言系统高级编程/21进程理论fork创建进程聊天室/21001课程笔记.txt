01 进程基础认知
    1.1 进程基础
        多任务编程
        任务本身要求顺序执行还是整个程序由多个子任务组成，程序都是按这种方式执行的，即使子任务相互独立，无相无关（即
        一个子任务的结果不影响 其他子任务的结果）时也是这样的
        多任务本质就是异步的，需要有多个产发事务。
        1.1.1 进程概述
            多进程和多线程是实现多任务编程的主要手段：
            计算机程序只不是是磁盘中可执行的，二进制的数据，只有被读取到内存中，被操作系统调用的时候才开始它们
            生命期。
            进程(有时被称为重量级进程）是程序的一次执行。
            每个进程都有自己的地址空间，内存，数据栈以及其他记录其运行轨迹的辅助数据。
            操作系统管理在其上运行的所有进程，并为这些进程公平的分配时间。在进程中存在父子进程的关系。
        1.1.2 进程和程序
            程序：是一个可执行的文件，是静态的，占有磁盘，不占计算机的运行资源
            进程：进程是一个动态的过程描述，占有计算机的资源，有一定的生命周期
            注意：
                同一个程序的不同运行过程是不同的进程，因为分配的计算机资源不同，生命周期也不同。
        1.1.3 进程特征
            1.动态性
                动态性是进程的基本特征，它是程序执行过程，它是有一定的生命期，它由创建而产生，由调度而执行，因得
                不到资源而暂停，并由撤消而死亡。而程序是静态的，它是存放在介质上一级有序指令的集合，无运动含义。
            2. 并发性
                并发性是进程的重要特征，同时也是OS的重要特征。并发性指多个进程实体同在于内存中，能在一段时间内同时
                运行。而程序是不能并发执行。
            3. 独立性
                进程是一个能独立运行的基本单位，即是一个独立获得资源和独立调度的单位，而程序不作为独立单位参加运行。
            4. 异步性
                进程按各自独立的不可预知的速度向前推进，即进程按异步方式进行，下是这一特征，将导致程序执行的不可再
                现性，因此OS必须采用某种措施来限制各进程推进序列以保证各程序间正常协调运行。
            5. 结构特征
                从结构上，进程实体由程序段、数据段和进程控制块三部分组成，称为"进程映象"
        1.1.4 产生进程
            外层应用程序----> shell -----> kernel ------> 硬件
    1.2 进程基本概念
        进程控制块(PCB)通常是系统内存占用区中一个连续内存，它存放着操作系统用于描述进程情况及控制进程程序运行
        所需的全部信息。
        1.2.1 进程控制块(pcb)
            1. 进程的标识符pid,name;
            2. 进程的调度信息：进程的状态，进程的优先级，进程的关系
            3. 进程控制信息：资源清单，信号量，互斥量，锁的信息，虚拟地址
            4. 处理机的信息：通用寄存器，指令计数器等。
        1.2.2 CPU时间片
            即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作为它的时间片，即该进程允许运行的时间，使
            各个程序从表面上看同时进行的，如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。
            如果进程在时间片结束前阻塞或者结束，则CPU当即进行切换。而不会造成CPU资源浪费。
            在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。
            但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如果处理公平，一种方法就是引入时间片，每
            个程序轮流执行。

        1.2.3 父子进程
            在系统中除了初始化进程每个进程都有一个父进程，可能有0个或者多个子进程，由此形成进程的父子关系。
            父子进程方便进行的管理和创建。

        1.2.4 PID
            进程的标识 ，是一个整数，由操作系统分配，每个进程的PID都不相同
            查看命令：ps -aux


02 进程状态和进程命令
    2.1 进程的状态
        运行态/执行态(Running):当一个进程在处理机上运行时，则称该进程处于运行状态

        就绪态(Ready):一个进程获得了除处理外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。

        阻塞态(Blocked):（又称挂起状态、等待状态）：一个进程正在等待某一事件发生(例如请求I/O而等待I/O完成等）而
        暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。

    2.2 进程状态之间的转换
        就绪态---> 运行态：当处理机空闲时，进程调试程序必将处理机分配给一个处于就绪态的进程，该进程便由就绪态
        转换为运行态。
        运行态--->阻塞态： 处于运行态的进程在运行过程中需要等待某一事件发生后(例如因I/O请求等待I/O完成后),才
        能继续运行，则该进程放弃处理机，从运行态转换为阻塞态。

        阻塞态--->就绪态：处于阻塞态的进程，若其等待的事件已经发生，于是进程由阻塞态转换为就绪态。

        运行态--->就绪态：处于运行状态的进程在其运行过程中，因分它处理机时间片已用完，而不得不让出(被抢占)处理
        机，于是进程由运行转换为就绪态。

        阻塞态--->运行态 与  就绪态---->阻塞态 这两种状态转换不可能发生。
    2.3 Linux下进程命令
        ps -aux中 STAT列表示进程状态：
            R : 运行
            S : 可中断睡眠Sleep
            D : 不中断睡眠
            T : 停止进程
            Z : 僵尸进程

            s : 进程的领导者
            < : 优先级较高的进程
            N : 优先级较低的进程
            + : 表示是前台的进程组
            | : 以线程的方式运行

        top 对系统进程的实时监控
            < > 进行翻页
            N n 进行翻页

        kill 杀死进程
            kill -9 PID
            kill -15 PDI

            kill -l
03 fork创建进程
    3.1 fork 使用
        os.fork()
            功能：创建当前进程的子进程
            参数：无
            返回值：
                0 代表执行子进程代码获取的fork返回值
                >0 就是子进程的PID,代表要执行的父进程代码得到的fork返回值
                -1 代表调用出错
        3.1.1 fork创建进程要点：
            依据实例为21002fork_tet.py
            1. 子进程会复制父进程全部代码段，包括fork之前产生的内存空间
            2. 子进程从fork的下一句开始执行，所以不会再创建进程
            3. 父子进程通常会根据fork返回值的差异选择执行不同的代码，而if结构也几乎是固定结构。
            4. 子进程虽然复制父进程的代码空间，但是有自己的特有属性。 比如：PID号，PCB等。
            5. 父子进程在执行上互补干扰，执行顺序不确定
            6. 父子进程空间独立，在本进程中对空间的操作不会影响到其他进程。
    3.2. 获取进程ID
        3.2.1 os.getpid()
            功能：获取当前进程的进程号
            返回值：返回当前进程进程号

        3.2.2 os.getppid()
            功能：获取父进程的进程号
            返回值：返回父进程的进程号

        3.2.3 os._exit(status)
            功能：退出
            参数：是一个整数表示进程的退出状态

        3.2.4 sys.exit([status])
            功能：退出进程
            参数：不写默认为0传入一个整数表示退出状态，传入一个字符串，则在进程退出时会打印该字符串。

04 孤儿进程和僵尸进程
    4.1 孤儿进程和僵尸进程简介
        4.1.1 孤儿进程
            一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被特定的系统
            进程所收养，并由该进程对它们完成状态收集工作。
        4.1.2 僵尸进程：
            一个进程创建子进程，如果子进程退出，而父进程并没有处理子进程的状态信息，那么子进程的部分信息仍然
            保存在系统中，这种进程称为僵尸进程，僵尸进程会浪费一定的系统资源。
    4.2 避免僵尸进程产生
        僵尸进程是一种机制可以保证只要父进程想知道子进程结束时的状态信息，就可以得到。即在每个进程退出的时候，
        内核释放该进程所有资源，包括打开的文件，占用的内存等，但是仍然为其保留一定的信息直到父进程通过来取时才
        释放。
        通过孤儿进程和僵尸进程的定义不难看出，在编程过程中应该避免大量僵尸进程的产生，可以从如下两个方面入手：
        1. 确保父进程先退出
        2. 父进程处理子进程的退出状态。
    4.3 僵尸进程处理方法
        4.3.1 通过wait()函数处理僵尸进程
            os.wait()
                功能：wait函数属于阻塞函数，会一直等待，直到子进程退出，wait函数会等待任意一个子进程退出
                参数：无
                返回值：返回一个元组(pid,status)
                可以通过宏函数os.WAITSTATUS(status)得到子进程退出的值。

        4.3.2 创建二级子进程
            1. 父进程创建子进程等待子进程退出
            2. 子进程创建二级子进程后退出
            3. 二级子进程成为孤儿处理具体事件

        4.3.3 通过信号处理子进程退出
            原理：子进程退出时会发送信号给父进程，如果父进程忽略子进程信号，则系统就会自动处理子进程退出
            方法：使用signal模块给父进程创建子进程前写如下语句：
                    import signal
                    signal.signal(signal.SIGCHLD,signal.SIG_IGN)

            特点：非阻塞，不会影响父进程运行。可以处理所有子进程退出。


05 聊天室编码
    5.1 代码要求
        功能：类似qq群功能
        1. 有人进入聊天室需要输入姓名，姓名不能重复
        2. 有人进入聊天室时，其他人会收到通知：xxx进入了聊天室
        3. 一个发消息，其他人会收到：xxx:xxxxxxxxxxxxxxxxxxxxx
        4. 有人退出儿天室，则其他人也会收到通知：xxx: 退出了聊天室
        5. 扩展功能：服务器可以向所有用户发送公告：管理员消息：xxxxxxxxx

    5.2 代码编写步骤
        1. 需要分析：达到什么效
        2. 技术点分析
        3. 结构设计
        4. 协议设定
        5. 逐个功能分析，

